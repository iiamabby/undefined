{"ast":null,"code":"/** Text hyphenation in Javascript.\n *  Copyright (C) 2021 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var SETTING_DEFAULT_ASYNC = false,\n    SETTING_DEFAULT_DEBUG = false,\n    SETTING_DEFAULT_HTML = false,\n    SETTING_DEFAULT_HYPH_CHAR = \"\\u00AD\",\n    SETTING_DEFAULT_MIN_WORD_LENGTH = 5,\n    SETTING_NAME_ASYNC = \"async\",\n    SETTING_NAME_DEBUG = \"debug\",\n    SETTING_NAME_HTML = \"html\",\n    SETTING_NAME_HYPH_CHAR = \"hyphenChar\",\n    SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n  var _global = typeof global === \"object\" ? global : typeof window === \"object\" ? window : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n  function cloneObj(source) {\n    var target = {};\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n  function keyOrDefault(object, key, defaultValue) {\n    if (key in object) {\n      return object[key];\n    }\n    return defaultValue;\n  }\n  function exceptionsFromDefinition(patternsDefinition, hyphenChar) {\n    return patternsDefinition.exceptions.reduce(function (exceptions, exception) {\n      exceptions[exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n      return exceptions;\n    }, {});\n  }\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var\n      //\n      asyncMode = keyOrDefault(options, SETTING_NAME_ASYNC, SETTING_DEFAULT_ASYNC),\n      caches = {},\n      debug = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG),\n      exceptions = {},\n      hyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, SETTING_DEFAULT_HYPH_CHAR),\n      patterns = createPatternTree(patternsDefinition.patterns.filter(function (p) {\n        return p !== \" \" && p !== \"\";\n      }))[0],\n      minWordLength = keyOrDefault(options, SETTING_NAME_MIN_WORD_LENGTH, SETTING_DEFAULT_MIN_WORD_LENGTH) >> 0,\n      skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML);\n\n    // Prepare cache\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition, hyphenChar);\n    caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\");\n    }\n    return function (text, options) {\n      options = options || {};\n      var localDebug = keyOrDefault(options, SETTING_NAME_DEBUG, debug),\n        localHyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, hyphenChar),\n        localMinWordLength = keyOrDefault(options, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0,\n        cacheKey = localHyphenChar + localMinWordLength;\n      if (!exceptions[cacheKey]) {\n        exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition, localHyphenChar);\n      }\n      if (!caches[cacheKey]) {\n        caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n      }\n      return start(text, patterns, caches[cacheKey], localDebug, localHyphenChar, skipHTML, localMinWordLength, asyncMode);\n    };\n  }\n  var NUMS = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"];\n  function createIterator(str) {\n    var i = 0;\n    function next() {\n      return str[i++];\n    }\n    return next;\n  }\n  function createPatternTree(patterns) {\n    var pattern,\n      symb,\n      maxPatternLength = 0,\n      patternTree = [{}],\n      nextPattern = createIterator(patterns);\n    while (pattern = nextPattern()) {\n      var ptr = patternTree,\n        symb,\n        weights = [],\n        patternLength = 0,\n        prevSymbIsNumber = false,\n        nextSymbol = createIterator(pattern.split(\"\"));\n      while (symb = nextSymbol()) {\n        if (NUMS.indexOf(symb) > -1) {\n          weights.push(parseInt(symb));\n          prevSymbIsNumber = true;\n        } else {\n          if (!prevSymbIsNumber && symb !== \".\") {\n            weights.push(0);\n          }\n          if (symb !== \".\") {\n            patternLength++;\n          }\n          ptr[0][symb] = ptr[0][symb] || [{}];\n          ptr = ptr[0][symb];\n          prevSymbIsNumber = false;\n        }\n      }\n      while (weights[weights.length - 1] === 0) {\n        weights.pop();\n      }\n      ptr[1] = weights;\n      ptr[2] = pattern;\n      if (maxPatternLength < patternLength) {\n        maxPatternLength = patternLength;\n      }\n    }\n    return [patternTree[0], maxPatternLength];\n  }\n  function createTextChunkReader(text, hyphenChar, skipHTML, minWordLength) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n      shouldHyphenate = void 0;\n      chunkReader: while (nextCharIndex <= text.length) {\n        var\n          //\n          nextChar = text.charAt(nextCharIndex++),\n          charIsLetter = !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n          charIsAngleOpen = nextChar === \"<\",\n          charIsAngleClose = nextChar === \">\",\n          charIsHyphen = nextChar === hyphenChar;\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_UNTOUCHED;\n            }\n            break;\n          }\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate = shouldHyphenate || nextTextChunk.length >= minWordLength && SHOULD_HYPHENATE;\n            break;\n          }\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_UNTOUCHED;\n        } while (0);\n        if (charIsAngleOpen && state !== STATE_RETURN_WORD && skipHTML && !isSpacelike(text.charAt(nextCharIndex))) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n          case STATE_RETURN_UNTOUCHED:\n            nextTextChunk += nextChar;\n            break chunkReader;\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n      return nextTextChunk || void 0;\n    }\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n    var isSpacelike = RegExp.prototype.test.bind(/\\s/);\n    var\n      //\n      nextCharIndex = 0,\n      SHOULD_HYPHENATE = 1,\n      SHOULD_SKIP = 2,\n      shouldHyphenate,\n      STATE_READ_TAG = 1,\n      STATE_READ_WORD = 2,\n      STATE_RETURN_UNTOUCHED = 3,\n      STATE_RETURN_WORD = 4,\n      state;\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n  function createCharIterator(str) {\n    var i = 0;\n    function nextChar() {\n      return str[i++];\n    }\n    function isLastLetter() {\n      return str.length === i + 1;\n    }\n    return [nextChar, isLastLetter];\n  }\n  function createStringSlicer(str) {\n    var i = 0,\n      slice = str;\n    function next() {\n      slice = str.slice(i++);\n      if (slice.length < 3) {\n        return;\n      }\n      return slice;\n    }\n    function isFirstCharacter() {\n      return i === 2;\n    }\n    return [next, isFirstCharacter];\n  }\n  function hyphenateWord(text, patternTree, debug, hyphenChar) {\n    var\n      //\n      levels = new Array(text.length + 1),\n      loweredText = (\".\" + text.toLocaleLowerCase() + \".\").split(\"\"),\n      p = [],\n      wordSlice,\n      letter,\n      treePtr,\n      nextPtr,\n      patternLevels,\n      patternEntityIndex = -1,\n      slicer,\n      nextSlice,\n      isFirstCharacter,\n      charIterator,\n      nextLetter,\n      isLastLetter;\n    for (var i = levels.length; i--;) levels[i] = 0;\n    slicer = createStringSlicer(loweredText);\n    nextSlice = slicer[0];\n    isFirstCharacter = slicer[1];\n    while (wordSlice = nextSlice()) {\n      patternEntityIndex++;\n      if (isFirstCharacter()) {\n        patternEntityIndex--;\n      }\n      treePtr = patternTree;\n      charIterator = createCharIterator(wordSlice);\n      nextLetter = charIterator[0];\n      isLastLetter = charIterator[1];\n      while (letter = nextLetter()) {\n        if (treePtr[letter] === undefined) {\n          break;\n        }\n        nextPtr = treePtr[letter];\n        treePtr = nextPtr[0];\n        patternLevels = nextPtr[1];\n        if (isLastLetter()) {\n          // ignore patterns for last letter\n          continue;\n        }\n        if (patternLevels === undefined) {\n          continue;\n        }\n        for (var k = 0; k < patternLevels.length; k++) levels[patternEntityIndex + k] = Math.max(patternLevels[k], levels[patternEntityIndex + k]);\n      }\n    }\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    var\n      //\n      hyphenatedText = \"\",\n      leveledText = \"\",\n      debugHyphenatedText = \"\";\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      if (debug) {\n        debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n        leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n      }\n    }\n    if (debug) console.log.apply(console, [text, \"->\"].concat(p).concat([\"->\"]).concat(levels).concat([\"->\", leveledText]).concat([\"->\", debugHyphenatedText]));\n    return hyphenatedText;\n  }\n  function start(text, patterns, cache, debug, hyphenChar, skipHTML, minWordLength, isAsync) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n      if (debug) {\n        console.log(\"----------------\\nHyphenation stats: \" + processedN + \" text chunks processed, \" + hyphenatedN + \" words hyphenated\");\n        console.log(\"Work time: \" + workTime / 1000);\n        console.log(\"Wait time: \" + (allTime - workTime) / 1000);\n        console.log(\"All time: \" + allTime / 1000);\n      }\n    }\n    var\n      //\n      cacheKey,\n      newText = \"\",\n      textChunk,\n      reader = createTextChunkReader(text, hyphenChar, skipHTML, minWordLength),\n      readNextTextChunk = reader[0],\n      shouldNextHyphenate = reader[1],\n      processedN = 0,\n      hyphenatedN = 0;\n    var\n      //\n      allTime = new Date(),\n      workTime = 0;\n    var resolveNewText = function () {};\n    function nextTick() {\n      var loopStart = new Date();\n      while ((!isAsync || new Date() - loopStart < 10) && (textChunk = readNextTextChunk())) {\n        cacheKey = textChunk.length ? \"$\" + textChunk : \"\";\n        if (shouldNextHyphenate()) {\n          if (cache[cacheKey] === undefined) {\n            cache[cacheKey] = hyphenateWord(textChunk, patterns, debug, hyphenChar);\n          }\n          if (textChunk !== cache[cacheKey]) {\n            hyphenatedN++;\n          }\n          textChunk = cache[cacheKey];\n        }\n        newText += textChunk;\n        processedN++;\n      }\n      workTime += new Date() - loopStart;\n      if (!textChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n  return createHyphenator;\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","createHyphenator","SETTING_DEFAULT_ASYNC","SETTING_DEFAULT_DEBUG","SETTING_DEFAULT_HTML","SETTING_DEFAULT_HYPH_CHAR","SETTING_DEFAULT_MIN_WORD_LENGTH","SETTING_NAME_ASYNC","SETTING_NAME_DEBUG","SETTING_NAME_HTML","SETTING_NAME_HYPH_CHAR","SETTING_NAME_MIN_WORD_LENGTH","_global","global","window","self","cloneObj","source","target","key","keyOrDefault","object","defaultValue","exceptionsFromDefinition","patternsDefinition","hyphenChar","exceptions","reduce","exception","replace","options","asyncMode","caches","debug","patterns","createPatternTree","filter","p","minWordLength","skipHTML","cacheKey","Error","text","localDebug","localHyphenChar","localMinWordLength","start","NUMS","createIterator","str","i","next","pattern","symb","maxPatternLength","patternTree","nextPattern","ptr","weights","patternLength","prevSymbIsNumber","nextSymbol","split","indexOf","push","parseInt","length","pop","createTextChunkReader","readNextTextChunk","nextTextChunk","shouldHyphenate","chunkReader","nextCharIndex","nextChar","charAt","charIsLetter","test","charIsAngleOpen","charIsAngleClose","charIsHyphen","state","STATE_READ_TAG","STATE_RETURN_UNTOUCHED","SHOULD_SKIP","STATE_READ_WORD","STATE_RETURN_WORD","SHOULD_HYPHENATE","isSpacelike","shouldNextHyphenate","RegExp","prototype","bind","createCharIterator","isLastLetter","createStringSlicer","slice","isFirstCharacter","hyphenateWord","levels","Array","loweredText","toLocaleLowerCase","wordSlice","letter","treePtr","nextPtr","patternLevels","patternEntityIndex","slicer","nextSlice","charIterator","nextLetter","undefined","k","Math","max","hyphenatedText","leveledText","debugHyphenatedText","console","log","apply","concat","cache","isAsync","done","allTime","Date","resolveNewText","newText","processedN","hyphenatedN","workTime","textChunk","reader","nextTick","loopStart","setTimeout","Promise","resolve"],"sources":["/Users/abdabthecreator/Documents/undefined-app/node_modules/hyphen/hyphen.js"],"sourcesContent":["/** Text hyphenation in Javascript.\n *  Copyright (C) 2021 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var SETTING_DEFAULT_ASYNC = false,\n    SETTING_DEFAULT_DEBUG = false,\n    SETTING_DEFAULT_HTML = false,\n    SETTING_DEFAULT_HYPH_CHAR = \"\\u00AD\",\n    SETTING_DEFAULT_MIN_WORD_LENGTH = 5,\n    SETTING_NAME_ASYNC = \"async\",\n    SETTING_NAME_DEBUG = \"debug\",\n    SETTING_NAME_HTML = \"html\",\n    SETTING_NAME_HYPH_CHAR = \"hyphenChar\",\n    SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n\n  var _global =\n    typeof global === \"object\"\n      ? global\n      : typeof window === \"object\"\n      ? window\n      : typeof self === \"object\"\n      ? self\n      : typeof this === \"object\"\n      ? this\n      : {};\n\n  function cloneObj(source) {\n    var target = {};\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function keyOrDefault(object, key, defaultValue) {\n    if (key in object) {\n      return object[key];\n    }\n    return defaultValue;\n  }\n\n  function exceptionsFromDefinition(patternsDefinition, hyphenChar) {\n    return patternsDefinition.exceptions.reduce(function (\n      exceptions,\n      exception\n    ) {\n      exceptions[exception.replace(/\\-/g, \"\")] = exception.replace(\n        /\\-/g,\n        hyphenChar\n      );\n      return exceptions;\n    },\n    {});\n  }\n\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var //\n      asyncMode = keyOrDefault(\n        options,\n        SETTING_NAME_ASYNC,\n        SETTING_DEFAULT_ASYNC\n      ),\n      caches = {},\n      debug = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG),\n      exceptions = {},\n      hyphenChar = keyOrDefault(\n        options,\n        SETTING_NAME_HYPH_CHAR,\n        SETTING_DEFAULT_HYPH_CHAR\n      ),\n      patterns = createPatternTree(\n        patternsDefinition.patterns.filter(function (p) {\n          return p !== \" \" && p !== \"\";\n        })\n      )[0],\n      minWordLength =\n        keyOrDefault(\n          options,\n          SETTING_NAME_MIN_WORD_LENGTH,\n          SETTING_DEFAULT_MIN_WORD_LENGTH\n        ) >> 0,\n      skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML);\n\n    // Prepare cache\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = exceptionsFromDefinition(\n      patternsDefinition,\n      hyphenChar\n    );\n    caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\n        \"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\"\n      );\n    }\n\n    return function (text, options) {\n      options = options || {};\n\n      var localDebug = keyOrDefault(options, SETTING_NAME_DEBUG, debug),\n        localHyphenChar = keyOrDefault(\n          options,\n          SETTING_NAME_HYPH_CHAR,\n          hyphenChar\n        ),\n        localMinWordLength =\n          keyOrDefault(options, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >>\n          0,\n        cacheKey = localHyphenChar + localMinWordLength;\n\n      if (!exceptions[cacheKey]) {\n        exceptions[cacheKey] = exceptionsFromDefinition(\n          patternsDefinition,\n          localHyphenChar\n        );\n      }\n\n      if (!caches[cacheKey]) {\n        caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n      }\n\n      return start(\n        text,\n        patterns,\n        caches[cacheKey],\n        localDebug,\n        localHyphenChar,\n        skipHTML,\n        localMinWordLength,\n        asyncMode\n      );\n    };\n  }\n  var NUMS = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"];\n\n  function createIterator(str) {\n    var i = 0;\n\n    function next() {\n      return str[i++];\n    }\n\n    return next;\n  }\n\n  function createPatternTree(patterns) {\n    var pattern,\n      symb,\n      maxPatternLength = 0,\n      patternTree = [{}],\n      nextPattern = createIterator(patterns);\n\n    while ((pattern = nextPattern())) {\n      var ptr = patternTree,\n        symb,\n        weights = [],\n        patternLength = 0,\n        prevSymbIsNumber = false,\n        nextSymbol = createIterator(pattern.split(\"\"));\n\n      while ((symb = nextSymbol())) {\n        if (NUMS.indexOf(symb) > -1) {\n          weights.push(parseInt(symb));\n\n          prevSymbIsNumber = true;\n        } else {\n          if (!prevSymbIsNumber && symb !== \".\") {\n            weights.push(0);\n          }\n\n          if (symb !== \".\") {\n            patternLength++;\n          }\n\n          ptr[0][symb] = ptr[0][symb] || [{}];\n          ptr = ptr[0][symb];\n\n          prevSymbIsNumber = false;\n        }\n      }\n\n      while (weights[weights.length - 1] === 0) {\n        weights.pop();\n      }\n\n      ptr[1] = weights;\n      ptr[2] = pattern;\n\n      if (maxPatternLength < patternLength) {\n        maxPatternLength = patternLength;\n      }\n    }\n\n    return [patternTree[0], maxPatternLength];\n  }\n  function createTextChunkReader(text, hyphenChar, skipHTML, minWordLength) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n\n      shouldHyphenate = void 0;\n\n      chunkReader: while (nextCharIndex <= text.length) {\n        var //\n          nextChar = text.charAt(nextCharIndex++),\n          charIsLetter =\n            !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n          charIsAngleOpen = nextChar === \"<\",\n          charIsAngleClose = nextChar === \">\",\n          charIsHyphen = nextChar === hyphenChar;\n\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_UNTOUCHED;\n            }\n            break;\n          }\n\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate =\n              shouldHyphenate ||\n              (nextTextChunk.length >= minWordLength && SHOULD_HYPHENATE);\n            break;\n          }\n\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_UNTOUCHED;\n        } while (0);\n\n        if (\n          charIsAngleOpen &&\n          state !== STATE_RETURN_WORD &&\n          skipHTML &&\n          !isSpacelike(text.charAt(nextCharIndex))\n        ) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_RETURN_UNTOUCHED:\n            nextTextChunk += nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n      return nextTextChunk || void 0;\n    }\n\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n\n    var isSpacelike = RegExp.prototype.test.bind(/\\s/);\n\n    var //\n      nextCharIndex = 0,\n      SHOULD_HYPHENATE = 1,\n      SHOULD_SKIP = 2,\n      shouldHyphenate,\n      STATE_READ_TAG = 1,\n      STATE_READ_WORD = 2,\n      STATE_RETURN_UNTOUCHED = 3,\n      STATE_RETURN_WORD = 4,\n      state;\n\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n  function createCharIterator(str) {\n    var i = 0;\n\n    function nextChar() {\n      return str[i++];\n    }\n\n    function isLastLetter() {\n      return str.length === i + 1;\n    }\n\n    return [nextChar, isLastLetter];\n  }\n\n  function createStringSlicer(str) {\n    var i = 0,\n      slice = str;\n\n    function next() {\n      slice = str.slice(i++);\n\n      if (slice.length < 3) {\n        return;\n      }\n\n      return slice;\n    }\n\n    function isFirstCharacter() {\n      return i === 2;\n    }\n\n    return [next, isFirstCharacter];\n  }\n\n  function hyphenateWord(text, patternTree, debug, hyphenChar) {\n    var //\n      levels = new Array(text.length + 1),\n      loweredText = (\".\" + text.toLocaleLowerCase() + \".\").split(\"\"),\n      p = [],\n      wordSlice,\n      letter,\n      treePtr,\n      nextPtr,\n      patternLevels,\n      patternEntityIndex = -1,\n      slicer,\n      nextSlice,\n      isFirstCharacter,\n      charIterator,\n      nextLetter,\n      isLastLetter;\n\n    for (var i = levels.length; i--; ) levels[i] = 0;\n\n    slicer = createStringSlicer(loweredText);\n    nextSlice = slicer[0];\n    isFirstCharacter = slicer[1];\n\n    while ((wordSlice = nextSlice())) {\n      patternEntityIndex++;\n      if (isFirstCharacter()) {\n        patternEntityIndex--;\n      }\n\n      treePtr = patternTree;\n\n      charIterator = createCharIterator(wordSlice);\n      nextLetter = charIterator[0];\n      isLastLetter = charIterator[1];\n\n      while ((letter = nextLetter())) {\n        if (treePtr[letter] === undefined) {\n          break;\n        }\n\n        nextPtr = treePtr[letter];\n        treePtr = nextPtr[0];\n        patternLevels = nextPtr[1];\n\n        if (isLastLetter()) {\n          // ignore patterns for last letter\n          continue;\n        }\n\n        if (patternLevels === undefined) {\n          continue;\n        }\n\n        for (var k = 0; k < patternLevels.length; k++)\n          levels[patternEntityIndex + k] = Math.max(\n            patternLevels[k],\n            levels[patternEntityIndex + k]\n          );\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[\n      levels.length - 2\n    ] = 0;\n\n    var //\n      hyphenatedText = \"\",\n      leveledText = \"\",\n      debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText +=\n        (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n\n      if (debug) {\n        debugHyphenatedText +=\n          (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n        leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n      }\n    }\n\n    if (debug)\n      console.log.apply(\n        console,\n        [text, \"->\"]\n          .concat(p)\n          .concat([\"->\"])\n          .concat(levels)\n          .concat([\"->\", leveledText])\n          .concat([\"->\", debugHyphenatedText])\n      );\n\n    return hyphenatedText;\n  }\n  function start(\n    text,\n    patterns,\n    cache,\n    debug,\n    hyphenChar,\n    skipHTML,\n    minWordLength,\n    isAsync\n  ) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n\n      if (debug) {\n        console.log(\n          \"----------------\\nHyphenation stats: \" +\n            processedN +\n            \" text chunks processed, \" +\n            hyphenatedN +\n            \" words hyphenated\"\n        );\n        console.log(\"Work time: \" + workTime / 1000);\n        console.log(\"Wait time: \" + (allTime - workTime) / 1000);\n        console.log(\"All time: \" + allTime / 1000);\n      }\n    }\n\n    var //\n      cacheKey,\n      newText = \"\",\n      textChunk,\n      reader = createTextChunkReader(text, hyphenChar, skipHTML, minWordLength),\n      readNextTextChunk = reader[0],\n      shouldNextHyphenate = reader[1],\n      processedN = 0,\n      hyphenatedN = 0;\n\n    var //\n      allTime = new Date(),\n      workTime = 0;\n\n    var resolveNewText = function () {};\n\n    function nextTick() {\n      var loopStart = new Date();\n\n      while (\n        (!isAsync || new Date() - loopStart < 10) &&\n        (textChunk = readNextTextChunk())\n      ) {\n        cacheKey = textChunk.length ? \"$\" + textChunk : \"\";\n\n        if (shouldNextHyphenate()) {\n          if (cache[cacheKey] === undefined) {\n            cache[cacheKey] = hyphenateWord(\n              textChunk,\n              patterns,\n              debug,\n              hyphenChar\n            );\n          }\n\n          if (textChunk !== cache[cacheKey]) {\n            hyphenatedN++;\n          }\n\n          textChunk = cache[cacheKey];\n        }\n\n        newText += textChunk;\n        processedN++;\n      }\n\n      workTime += new Date() - loopStart;\n\n      if (!textChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n\n  return createHyphenator;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}